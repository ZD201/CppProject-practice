### **2. 简易计算器**

实现一个命令行计算器，支持加减乘除和括号运算。这个项目可以练习基本的输入输出、字符串处理和简单的算法（如中缀表达式求值）。





# `ExprCalc` 项目收获清单

通过实现 `ExprCalc` 命令行计算器项目，你将获得以下技能和经验，涵盖现代 C++ 编程、软件设计、工程实践和工具使用等方面，助力你成为一名优秀的 C++ 开发者。

## 1. 现代 C++ 编程技能

### 1.1. C++11 特性

- 自动类型推导 (`auto`)

  ：学习使用 

  ```
  auto
  ```

   简化变量声明，提高代码可读性，例如在迭代容器或处理复杂类型时。

  - 示例：`auto tokens = lexer.tokenize();`

- 移动语义与右值引用

  ：掌握 

  ```
  std::move
  ```

   和右值引用，优化资源管理，减少不必要的拷贝。

  - 示例：将 `std::vector<Token>` 移动到 `ShuntingYard::to_postfix`。

- **智能指针 (`std::unique_ptr`, `std::shared_ptr`)**：理解 RAII（资源获取即初始化），管理动态资源（如可能的符号表扩展）。

- Lambda 表达式

  ：用于函数映射表（如 

  ```
  sin
  ```

  、

  ```
  cos
  ```

  ）或调试日志的回调。

  - 示例：`std::for_each(tokens.begin(), tokens.end(), [](const Token& t) { ... });`

### 1.2. C++14 特性

- 泛型 Lambda

  ：简化回调函数的编写，特别是在处理 

  ```
  std::variant
  ```

   或调试输出时。

  - 示例：`auto visitor = [](auto&& value) { ... };`

- 返回类型推导

  ：简化函数签名，尤其在 

  ```
  Lexer
  ```

   或 

  ```
  Evaluator
  ```

   的辅助方法中。

  - 示例：`auto parse_number() -> double;`

### 1.3. C++17 特性

- 结构化绑定

  ：优雅地解构 

  ```
  std::variant
  ```

   或 

  ```
  std::pair
  ```

  ，提高代码可读性。

  - 示例：`auto [type, value] = token;`

- std::variant

  ：掌握多类型存储（如 

  ```
  Token
  ```

   的值），并通过 

  ```
  std::visit
  ```

   安全访问。

  - 示例：处理 `Token` 的 `double` 或 `std::string_view` 值。

- std::optional

  ：用于符号表查询或错误处理，表示可能不存在的值。

  - 示例：`std::optional<double> get_variable(std::string_view name);`

- std::string_view

  ：学习高效字符串处理，减少拷贝开销。

  - 示例：`Lexer` 使用 `std::string_view` 解析输入。

- if constexpr

  ：在编译期优化分支逻辑，特别是在处理 

  ```
  std::variant
  ```

   时。

  - 示例：`if constexpr (std::is_same_v<decltype(value), double>) { ... }`

### 1.4. C++20 特性（可选）

- std::format

  ：格式化错误信息或调试日志，替代传统的 

  ```
  std::stringstream
  ```

  。

  - 示例：`std::format("错误：括号不匹配，位置 {}", pos);`

- **Concepts（概念）**：尝试为 `Token` 或 `Evaluator` 定义模板约束，提升代码可读性和类型安全。

## 2. 软件设计与架构

### 2.1. 模块化设计

- **职责单一原则 (SRP)**：通过实现 `Lexer`、`ShuntingYard`、`Evaluator` 和 `Calculator` 等模块，理解如何将功能分解为高内聚、低耦合的组件。
- **关注点分离**：学习将用户界面（`CliHandler`）与核心逻辑（`Calculator`）分开，增强代码可维护性。
- **接口设计**：为每个模块设计清晰的接口（如 `Calculator::evaluate`），掌握抽象与封装。

### 2.2. 设计模式

- **工厂模式**：在 `Lexer` 中为不同类型的 `Token`（如数字、操作符）设计创建逻辑。
- **策略模式**：为数学函数（如 `sin`、`cos`）实现统一的接口，存储在 `Evaluator` 的函数映射表中。
- **单例模式（可选）**：为全局资源（如 `SymbolTable` 或 `Logger`）实现单例，确保资源共享。

### 2.3. 可扩展性

- 学习设计支持扩展的系统，例如：
  - 添加新函数（如 `log`、`exp`）只需更新函数映射表。
  - 支持变量通过 `SymbolTable` 实现。
  - 支持自定义操作符通过扩展 `Token` 的优先级映射。

### 2.4. 异常安全

- 掌握强异常保证（Strong Exception Guarantee），确保异常发生时程序状态不被破坏。
  - 示例：`Evaluator` 在除零时抛出 `CalculationError`，不影响栈状态。
- 学习 RAII 管理资源，如 `Logger` 的文件句柄或动态分配的符号表。

## 3. 算法与数据结构

### 3.1. 核心算法

- **调度场算法 (Shunting-Yard)**：理解如何将中缀表达式转换为后缀表达式（RPN），处理操作符优先级和括号。
- **RPN 求值**：使用栈结构高效计算后缀表达式，掌握栈操作的实际应用。
- **词法分析**：实现状态机或前向检查，解析复杂输入（如一元负号、多位数）。

### 3.2. 数据结构

- **std::vector**：存储 `Token` 序列，学习动态数组的性能特性。
- **std::queue**：用于 RPN 输出，理解队列的 FIFO 特性。
- **std::stack**：用于操作符栈和操作数栈，掌握栈的 LIFO 操作。
- **std::unordered_map**：在 `SymbolTable` 和函数映射表中应用哈希表，优化查询性能。

## 4. 错误处理与健壮性

- **自定义异常**：设计 `CalculationError` 及其子类（如 `LexerError`），学习如何提供详细的错误信息（如错误位置）。

- **错误分类**：通过 `ErrorCode` 枚举区分不同错误场景（如括号不匹配、除零）。

- 用户友好提示

  ：将技术性错误转换为易懂的提示，提升用户体验。

  - 示例：`错误：未定义变量 x，位置 5`。

## 5. 工程实践

### 5.1. 测试驱动开发 (TDD)

- 单元测试

  ：使用 GoogleTest 编写测试用例，覆盖：

  - `Lexer`：数字、操作符、一元负号等。
  - `ShuntingYard`：复杂表达式的 RPN 输出。
  - `Evaluator`：除零、变量解析等。
  - `Calculator`：端到端功能。

- **参数化测试**：使用 `TEST_P` 批量测试多种输入。

- **测试覆盖率**：学习如何确保边界情况（如空输入、非法字符）被覆盖。

### 5.2. 构建系统

- CMake

  ：掌握编写模块化的 

  ```
  CMakeLists.txt
  ```

  ，支持库、可执行文件和测试目标。

  - 示例：配置 `add_library` 和 `target_link_libraries`。

- **项目组织**：学习如何组织源代码、头文件和测试目录，适合多人协作或开源项目。

### 5.3. 调试与日志

- **调试模式**：实现 `Logger` 模块，打印中间结果（如 Token 序列、RPN 队列），提升调试效率。
- **日志管理**：使用 `std::filesystem` 将日志写入文件，学习文件 I/O 和路径处理。
- **工具使用**：尝试 Clang-Tidy 检查代码质量，Valgrind 检测内存泄漏。

## 6. 工具与生态

- **GoogleTest**：深入学习测试框架，掌握 `ASSERT`、`EXPECT` 和 Mock 对象。
- **CMake**：理解构建系统的配置，如编译选项、依赖管理和安装目标。
- **Clang-Tidy**：使用静态分析工具优化代码风格和发现潜在问题。
- **Valgrind**：检测内存泄漏和未定义行为，提升代码健壮性。
- **Doxygen**：为代码生成文档，学习工业级文档规范。

## 7. 软技能与职业素养

- **代码可读性**：遵循命名规范（如 Google C++ Style Guide），使用 `const` 和 `noexcept` 提高代码质量。
- **文档编写**：为项目编写清晰的 `README.md` 和代码注释，培养技术写作能力。
- **问题分解**：将复杂问题（如表达式解析）分解为小模块，锻炼系统设计能力。
- **时间管理**：通过分阶段实现（核心逻辑 → CLI → 扩展功能），学习项目规划和迭代开发。

## 8. 实际应用场景

- **算法应用**：调度场算法和 RPN 求值可应用于编译器、解释器或数学软件开发。
- **模块化设计**：在大型项目中复用模块化思想，如数据库查询解析器或脚本引擎。
- **错误处理**：异常机制可应用于金融、嵌入式或其他高可靠性系统。
- **测试经验**：TDD 和单元测试技能直接适用于工业级软件开发。

## 9. 未来学习方向

- **更复杂的解析器**：基于 `ExprCalc`，尝试实现递归下降解析器或 AST（抽象语法树）解析。
- **性能优化**：学习多线程（如 `std::async`）或 JIT 编译加速计算。
- **跨平台开发**：将项目扩展为 GUI 应用（如使用 Qt），学习跨平台开发。
- **开源贡献**：将项目开源到 GitHub，学习版本控制和社区协作。

## 10. 项目成果

- **可运行的计算器**：一个支持基本运算、变量和函数的命令行工具。
- **代码库**：一个模块化、可测试的 C++ 项目，可作为个人作品集展示。
- **技能提升**：从 C++ 语法到工程实践的全面成长，为后续学习（如编译器开发、嵌入式系统）奠定基础。

------

通过这个项目，你将从零开始构建一个工业级 C++ 应用，掌握现代 C++ 特性、设计模式和工程实践，同时培养解决复杂问题的能力。祝你 coding 愉快，C++ 水平突飞猛进！